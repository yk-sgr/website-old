[{"content":"First of all: I am definitely not a Flutter professional. But over the years I’ve gained a lot of experience with other programming languages. To cut right to the chase: When I first looked at Flutter, I disliked the amount of boilerplate code.\n 1. Routing auto_route is a great package. Using code generation, auto_route helps set up the routing of the app in a few lines. I actually don’t like the Navigation 2 approach of Flutter (at least when I set it up myself), but that’s no problem at all with auto_route.\n2. State Management There are a lot of state management packages out there. But I recommend riverpod, though. At the time of writing, pre-release 1.0 is out, but unfortunately the documentation is not quite up to date. However, it does save a lot of time writing boilerplate code. Maybe I’m going to extend this list in the future. But I really wanted to share my thoughts about these packages.\nHappy Coding!\n","permalink":"https://yseeger.me/blog/how-i-reduced-flutter-boilerplate-code/","summary":"How to reduce boilerplate code in your flutter app.","title":"How I reduced Flutter boilerplate code"},{"content":"In this article I will show you what I think is the best way to configure your Go Application.\n In the past I’ve been trying a lot of configuration formats like JSON, YAML, properties and much more. But in the recent past I see myself just using environment variables.\nIn the modern cloud age where we rely heavily on stateless services, environment variables are a good fit, especially when using Docker or Kubernetes.\nTo simplify my code for loading configurations, I make use of godotenv and envconfig.\n godotenv loads .env files if they exist, what they usually do in my local development environments. envconfig “loads” existing environment variables into a struct. It supports the use of struct tags to specify alternate, default, and required environment variables.  config.go 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package main import ( \u0026#34;log\u0026#34; \u0026#34;github.com/joho/godotenv\u0026#34; \u0026#34;github.com/kelseyhightower/envconfig\u0026#34; ) type Config struct { Debug bool `default:\u0026#34;false\u0026#34;` PostgresDSN string `envconfig:\u0026#34;POSTGRES_DSN\u0026#34;` Port string `default:\u0026#34;:3000\u0026#34;` } func LoadConfig() *Config { _ = godotenv.Load() var cfg Config err := envconfig.Process(\u0026#34;SERVICE\u0026#34;, \u0026amp;cfg) if err != nil { log.Fatalf(\u0026#34;could not load config: %v\u0026#34;, err) } return \u0026amp;cfg }  \nIf you have sucessfully built your configuration struct you can initialize your config as following:\nmain.go 1 2 3 4 5 6 7 8  package main import \u0026#34;fmt\u0026#34; func main() { cfg := LoadConfig() fmt.Println(cfg.PostgresDSN) }  \nYour application now loads .env files if provided or existing environment variables.\n.env 1 2  SERVICE_DEBUG=true SERVICE_POSTGRES_DSN=postgresql://user@localhost  \n I’m happy if I could help you get some inspiration or solve your problem.\n","permalink":"https://yseeger.me/blog/how-i-configure-my-go-applications/","summary":"How to configure your Go Application.","title":"How I configure my Go Applications"}]